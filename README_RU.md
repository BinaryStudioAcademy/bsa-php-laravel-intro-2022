# Winter Binary Studio Academy 2022 PHP

## Домашнее задание Laravel introduction

**Логирование** - это сохранение Информация о всех процессах резервного копирования, аварийного завершения приложения, и т.д. Все события должны автоматически сохраняется в лог, так что Вы всегда можете быть в курсе текущего состояния программы.
Каждый раз, когда нам нужно создать программу, появляется необходимость интеграции системы логирования. Причины ее имплементации разнообразны:
- отладка;
- статистика;
- потенциальные предупреждения;
- общие ошибки.
- …

Большинство фреймворков и пакетов соответствуют стандарту PSR-3, описывающему, как работает система логирования. По сути это интерфейс, на который вы должны полагаться, передавая журналы в систему. Среди них Monolog является наиболее используемым, поскольку он очень гибок и легок для понимания.
Возвращаясь к существу, реализация PSR-3 описывает восемь уровней журнала. В порядке «серьезности»: чрезвычайная ситуация, оповещение, критическая ошибка, ошибка, предупреждение, оповещение, информация и отладка. (Emergency, Alert, Critical, Error, Warning, Notice, Informational, Debug)

_**Вашей задачей будет разработать свою систему логирования.**_

### Перед началом работы

- Ознакомиться с [теоретическими знаниями](https://en.wikipedia.org/wiki/Logging_(software)).
- Ознакомиться с [стандартом PSR-3](https://www.php-fig.org/psr/psr-3/).
- Ознакомиться с [возможностями логирования в системе Laravel](https://laravel.com/docs/8.x/logging).

### Задание 1

* Написать миграцию на создание таблицы logs в базе данных. В таблице должны присутствовать следующие поля:


     ‘level’. В этой колонке могут быть только следующие значения: `['info', 'warning', 'error', 'debug', 'critical', 'alert', 'emergency', 'notice']`.

     ‘driver'. По умолчанию значение должно быть database.

     ‘message’. Обязательное поле.

     ‘trace’. Обязательное поле.

     ‘channel’. Может принимать значение null, если данные отсутствуют.

     ‘created_at’, ‘updated_at’. Для реализации использовать `$table->timestamps();`.



* Выполнить миграцию с помощью команды php artisan migrate.
* Повинна бути можливість відкотити (Rollback) миграцию.
* Создать Модель 'Log' в директории 'Название_вашого_проекта/app/Models/
* Написать seeder для заполнения таблицы случайными (random) данными.

### Задание 2

* Реализовать интерфейс LogRepositoryInterface и зарегистрировать в сервис контейнере Laravel.
* Реализовать клас `GetAllLogsAction` и вернуть `GetAllLogsResponse` со всеми логами.
* Реализовать клас `GetLogsByLevelAction` и вернуть `GetLogsByLevelResponse`. _На входе массив с названиями уровней логов. Необходимо вернуть логи только соответствующих уровней._
* Реализовать клас `GetLogsStatisticAction` и вернуть `GetLogsStatisticResponse`. _Необходимо получить данные в со структурой 'название уровня' и 'количество логов этого уровня' Например:_


        [
          'info' => 5,
          'warning' => 3,
          'error' => 3,
          'debug' => 21,
          'critical' => 1,
          'alert' => 0,
          'emergency' => 0,
          'notice' => 0,
        ]

### Задание 3

* Реализовать маршрут `api/logs` в файле `routes/api.php` по которому можно получить все логи в формате json
* Реализовать маршрут `api/logs/statistic` в файле `routes/web.php` по которому можно получить статистику по всем уровням и отрендировать их во view `logs.blade.php`
* Реализовать маршрут `api/logs/{level}` в файле `routes/api.php` по которому можно получить все логи определенного уровня в формате json

### Задание 4* _(Не обязательно для выполнения)_
Вам нужно будет реализовать то же, что и в задании 3, но использовать логирование Laravel из коробки. Вам нужно будет искусственно заполнить журнал логирования, который находится по пути "Название_вашого_проекта/storage/logs/laravel.log". Следующим шагом будет реализация LogStorageService. Вам нужно будет распарсить файл логов и вернуть результаты в таком же виде, как и в задании 3.
* Реализовать маршрут `api/storage/logs` в файле `routes/api.php` по которому можно получить все логи в формате json
* Реализовать маршрут `api/storage/logs/statistic` в файле `routes/web.php` по которому можно получить статистику по всем уровням и отрендировать их во view`logs_storage.blade.php`
* Реализовать маршрут `api/storage/logs/{level}` в файле `routes/api.php` по которому можно получить все логи определенного уровня в формате json

### Проверка
Свое решение можно проверить запустив тесты PHPUnit.

```bash
./vendor/bin/phpunit
```

### Docker

```
cp .env.example .env
cp .env.testing.example .env.testing
cp docker-compose.override.yml.example .docker-compose.override.yml
docker-compose up -d --build
docker-compose exec app php artisan migrate
docker-compose exec app php artisan db:seed
docker-compose exec app ./vendor/bin/phpunit
```

### Критерии оценки

* Задания выполнены корректно (7 баллов)

* Валидация данных выполнена корректно (используются кастомные исключения, приложение не ломается при невалдиных входных значениях) (1 балл)

* Код написан чисто, комментариев в коде нет и код соответствует стандарту [PSR-12](https://www.php-fig.org/psr/psr-12/) (1 балл)

* Awesomness - остается на усмотрение проверяющего (1 балл)

### Финализируем

Ваше решение необходимо разместить в отдельной репозитории на [Bitbucket](https://bitbucket.org/)
и отправить ссылку на него.

Задавайте вопросы в комментариях к задаче при возникновении проблем.

*Форкать* репозиторий **запрещено**!
